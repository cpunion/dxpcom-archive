/*
 * DO NOT EDIT.  THIS FILE IS GENERATED FROM nsINavHistoryService.idl
 */

module mozilla.dxpcom.nsINavHistoryServiceD;

public import mozilla.dxpcom.nsrootidlD;


public import mozilla.xpcom.nsINavHistoryService;


public import mozilla.dxpcom.nsINavHistoryServiceD;

public import mozilla.xpcom.nsISupports;
public import mozilla.dxpcom.nsISupportsD;
public import mozilla.xpcom.nsIArray;
public import mozilla.dxpcom.nsIArrayD;
public import mozilla.xpcom.nsIURI;
public import mozilla.dxpcom.nsIURID;

public import mozilla.xpcom.nsIFile;

public import mozilla.dxpcom.nsIFileD;

public import mozilla.xpcom.nsINavHistoryService;

import mozilla.dxpcom.nsINavHistoryServiceD;

public import mozilla.xpcom.nsINavHistoryService;

import mozilla.dxpcom.nsINavHistoryServiceD;

public import mozilla.xpcom.nsINavHistoryService;

import mozilla.dxpcom.nsINavHistoryServiceD;

public import mozilla.xpcom.nsINavHistoryService;

import mozilla.dxpcom.nsINavHistoryServiceD;

public import mozilla.xpcom.nsINavHistoryService;

import mozilla.dxpcom.nsINavHistoryServiceD;

public import mozilla.xpcom.nsINavHistoryService;

import mozilla.dxpcom.nsINavHistoryServiceD;

public import mozilla.xpcom.nsITreeColumns;

import mozilla.dxpcom.nsITreeColumnsD;

public import mozilla.xpcom.nsIWritablePropertyBag;

public import mozilla.dxpcom.nsIWritablePropertyBagD;


/* starting wrapper class:    nsINavHistoryResultNode */
class nsINavHistoryResultNodeD : public nsISupportsD {

  static const nsIID IID = NS_INAVHISTORYRESULTNODE_IID;


  alias nsINavHistoryResultNode InnerType;

  this(nsINavHistoryResultNode intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryResultNode opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryResultNode value) {
    inner = value;
  }

  /**
   * Indentifies the parent result node in the result set. This is null for
   * top level nodes.
   */
  /* readonly attribute nsINavHistoryContainerResultNode parent; */
  nsINavHistoryContainerResultNodeD  Parent(){
    nsINavHistoryContainerResultNode value;
    nsresult __result = inner.GetParent(&value);
    CheckException(__result);
    return new nsINavHistoryContainerResultNodeD(value);
  }

  /**
   * URI of the resource in question. For visits and URLs, this is the URL of
   * the page. For folders and queries, this is the place: URI of the
   * corresponding folder or query. This may be empty for other types of
   * objects like host containers.
   */
  /* readonly attribute AUTF8String uri; */
  char[] Uri(){
    scope auto value = new ACString();
    nsresult __result = inner.GetUri(cast(nsACString*)value);
    CheckException(__result);
    return value.GetString();
  }

  /**
   * Identifies the type of this node. This node can then be QI-ed to the
   * corresponding specialized result node interface. The remote_container one
   * is a little weird, it is a temportary folder generated by the remote
   * container API. Note that bookmark folders can also be filled by the
   * remote container API (these are the entrypoints for the API) and may
   * have a remote container type as well.
   */
  enum { RESULT_TYPE_URI = 0U }

  enum { RESULT_TYPE_VISIT = 1U }

  enum { RESULT_TYPE_FULL_VISIT = 2U }

  enum { RESULT_TYPE_HOST = 3U }

  enum { RESULT_TYPE_REMOTE_CONTAINER = 4U }

  enum { RESULT_TYPE_QUERY = 5U }

  enum { RESULT_TYPE_FOLDER = 6U }

  enum { RESULT_TYPE_SEPARATOR = 7U }

  /* readonly attribute PRUint32 type; */
  PRUint32 Type(){
    PRUint32 value;
    nsresult __result = inner.GetType(&value);
    CheckException(__result);
    return value;
  }

  /**
   * Title of the web page, or of the node's grouping (day, host, folder, etc)
   */
  /* readonly attribute AUTF8String title; */
  char[] Title(){
    scope auto value = new ACString();
    nsresult __result = inner.GetTitle(cast(nsACString*)value);
    CheckException(__result);
    return value.GetString();
  }

  /**
   * Total number of times the URI has ever been accessed. For hosts, this
   * is the total of the children under it, NOT the total times the host has
   * been accessed (this would require an additional query, so is not given
   * by default when most of the time it is never needed).
   */
  /* readonly attribute PRUint32 accessCount; */
  PRUint32 AccessCount(){
    PRUint32 value;
    nsresult __result = inner.GetAccessCount(&value);
    CheckException(__result);
    return value;
  }

  /**
   * This is the time the user accessed the page.
   *
   * If this is a visit, it is the exact time that the page visit occurred.
   *
   * If this is a URI, it is the most recent time that the URI was visited.
   * Even if you ask for all URIs for a given date range long ago, this might
   * contain today's date if the URI was visited today.
   *
   * For hosts, or other node types with children, this is the most recent
   * access time for any of the children.
   *
   * For days, this is midnight on the morning of the day in question in
   * UTC time.
   */
  /* readonly attribute PRTime time; */
  PRTime Time(){
    PRTime value;
    nsresult __result = inner.GetTime(&value);
    CheckException(__result);
    return value;
  }

  /**
   * This URI can be used as an image source URI and will give you the favicon
   * for the page. It is *not* the URI of the favicon, but rather something
   * that will resolve to the actual image.
   *
   * In most cases, this is an annotation URI that will query the favicon
   * service. If the entry has no favicon, this is the chrome URI of the
   * default favicon. If the favicon originally lived in chrome, this will
   * be the original chrome URI of the icon.
   */
  /* readonly attribute nsIURI icon; */
  nsIURID  Icon(){
    nsIURI value;
    nsresult __result = inner.GetIcon(&value);
    CheckException(__result);
    return new nsIURID(value);
  }

  /**
   * This is the number of levels between this node and the top of the
   * hierarchy. The members of result.children have indentLevel = 0, their
   * children have indentLevel = 1, etc.
   */
  /* readonly attribute PRUint32 indentLevel; */
  PRUint32 IndentLevel(){
    PRUint32 value;
    nsresult __result = inner.GetIndentLevel(&value);
    CheckException(__result);
    return value;
  }

  /**
   * Value with undefined meaning for use by the view. Its initial value will
   * be -1. The tree view uses this value to indicate the row in the tree that
   * this node is at. Other views may use this value however they choose.
   */
  /* attribute PRInt32 viewIndex; */
  PRInt32 ViewIndex(){
    PRInt32 value;
    nsresult __result = inner.GetViewIndex(&value);
    CheckException(__result);
    return value;
  }
  void ViewIndex(PRInt32 aViewIndex){
    PRInt32 value;
    nsresult __result = inner.SetViewIndex(value);
    CheckException(__result);
  }

  /**
   * You can use this to associate temporary information with the result node.
   * This property bag is associated with the result node and is not persisted
   * in any way.
   */
  /* readonly attribute nsIWritablePropertyBag propertyBag; */
  nsIWritablePropertyBagD  PropertyBag(){
    nsIWritablePropertyBag value;
    nsresult __result = inner.GetPropertyBag(&value);
    CheckException(__result);
    return new nsIWritablePropertyBagD(value);
  }

  /**
   * When this item is in a bookmark folder (parent is of type folder), this is
   * the index into that folder of this node. These indices start at 0 and
   * increase in the order that they appear in the bookmark folder. For items
   * that are not in a bookmark folder, this value is -1.
   */
  /* readonly attribute PRInt32 bookmarkIndex; */
  PRInt32 BookmarkIndex(){
    PRInt32 value;
    nsresult __result = inner.GetBookmarkIndex(&value);
    CheckException(__result);
    return value;
  }

private:
  nsINavHistoryResultNode inner;

}


/* starting wrapper class:    nsINavHistoryVisitResultNode */
/**
 * When you request RESULT_TYPE_VISIT from query options, you will get this
 * interface for each item, which includes the session ID so that we can
 * group items from the same session together.
 */
class nsINavHistoryVisitResultNodeD : public nsINavHistoryResultNodeD {

  static const nsIID IID = NS_INAVHISTORYVISITRESULTNODE_IID;


  alias nsINavHistoryVisitResultNode InnerType;

  this(nsINavHistoryVisitResultNode intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryVisitResultNode opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryVisitResultNode value) {
    inner = value;
  }

  /**
   * This indicates the session ID of the * visit. This is used for session
   * grouping when a tree view is sorted by date.
   */
  /* readonly attribute PRInt64 sessionId; */
  PRInt64 SessionId(){
    PRInt64 value;
    nsresult __result = inner.GetSessionId(&value);
    CheckException(__result);
    return value;
  }

private:
  nsINavHistoryVisitResultNode inner;

}


/* starting wrapper class:    nsINavHistoryFullVisitResultNode */
/**
 * This structure will be returned when you request RESULT_TYPE_FULL_VISIT in
 * the query options. This includes uncommonly used information about each
 * visit.
 */
class nsINavHistoryFullVisitResultNodeD : public nsINavHistoryVisitResultNodeD {

  static const nsIID IID = NS_INAVHISTORYFULLVISITRESULTNODE_IID;


  alias nsINavHistoryFullVisitResultNode InnerType;

  this(nsINavHistoryFullVisitResultNode intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryFullVisitResultNode opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryFullVisitResultNode value) {
    inner = value;
  }

  /**
   * This indicates the visit ID of the visit.
   */
  /* readonly attribute PRInt64 visitId; */
  PRInt64 VisitId(){
    PRInt64 value;
    nsresult __result = inner.GetVisitId(&value);
    CheckException(__result);
    return value;
  }

  /**
   * This indicates the referring visit ID of the visit. The referrer should
   * have the same sessionId.
   */
  /* readonly attribute PRInt64 referringVisitId; */
  PRInt64 ReferringVisitId(){
    PRInt64 value;
    nsresult __result = inner.GetReferringVisitId(&value);
    CheckException(__result);
    return value;
  }

  /**
   * Indicates the transition type of the visit.
   * One of nsINavHistoryService.TRANSITION_*
   */
  /* readonly attribute PRInt32 transitionType; */
  PRInt32 TransitionType(){
    PRInt32 value;
    nsresult __result = inner.GetTransitionType(&value);
    CheckException(__result);
    return value;
  }

private:
  nsINavHistoryFullVisitResultNode inner;

}


/* starting wrapper class:    nsINavHistoryContainerResultNode */
class nsINavHistoryContainerResultNodeD : public nsINavHistoryResultNodeD {

  static const nsIID IID = NS_INAVHISTORYCONTAINERRESULTNODE_IID;


  alias nsINavHistoryContainerResultNode InnerType;

  this(nsINavHistoryContainerResultNode intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryContainerResultNode opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryContainerResultNode value) {
    inner = value;
  }

  /**
 * Base class for container results. This includes all types of groupings.
 * Bookmark folders and places queries will be QueryResultNodes which extends
 * these items.
 */
/**
   * Set this to allow descent into the container. When closed, attempting
   * to call getChildren or childCount will result in an error. You should
   * set this to false when you are done reading.
   *
   * For HOST and DAY groupings, doing this is free since the children have
   * been precomputed. For queries and bookmark folders, being open means they
   * will keep themselves up-to-date by listening for updates and re-querying
   * as needed.
   */
  /* attribute boolean containerOpen; */
  PRBool ContainerOpen(){
    PRBool value;
    nsresult __result = inner.GetContainerOpen(&value);
    CheckException(__result);
    return value;
  }
  void ContainerOpen(PRBool aContainerOpen){
    nsresult __result = inner.SetContainerOpen(aContainerOpen);
    CheckException(__result);
  }

  /**
   * This indicates whether this node "may" have children, and can be used
   * when the container is open or closed. When the container is closed, it
   * will give you an exact answer if the node can easily be populated (for
   * example, a bookmark folder). If not (for example, a complex history query),
   * it will return true. When the container is open, it will always be
   * accurate. It is intended to be used to see if we should draw the "+" next
   * to a tree item.
   */
  /* readonly attribute boolean hasChildren; */
  PRBool HasChildren(){
    PRBool value;
    nsresult __result = inner.GetHasChildren(&value);
    CheckException(__result);
    return value;
  }

  /**
   * This gives you the children of the nodes. It is preferrable to use this
   * interface over the array one, since it avoids creating an nsIArray object
   * and the interface is already the correct type.
   */
  /* readonly attribute PRUint32 childCount; */
  PRUint32 ChildCount(){
    PRUint32 value;
    nsresult __result = inner.GetChildCount(&value);
    CheckException(__result);
    return value;
  }

  /* nsINavHistoryResultNode getChild (in PRUint32 index); */
  nsINavHistoryResultNodeD  GetChild(PRUint32 index){
    nsINavHistoryResultNode _retval;
    nsresult __result = inner.GetChild(index, &_retval);
    CheckException(__result);
    return new nsINavHistoryResultNodeD(_retval);
  }

  /**
   * Returns false if this node's list of children can be modified
   * (adding or removing children, or reordering children), or true if
   * the UI should not allow the list of children to be modified.
   * This is false for bookmark folder nodes unless setFolderReadOnly() has
   * been called to override it, and true for non-folder nodes. If this
   * container is a remote container this flag may be redefined by the
   * remote container provider.
   */
  /* readonly attribute boolean childrenReadOnly; */
  PRBool ChildrenReadOnly(){
    PRBool value;
    nsresult __result = inner.GetChildrenReadOnly(&value);
    CheckException(__result);
    return value;
  }

  /**
   * This is a string representing the remote container API service that is
   * responsible for this container. It is empty if there is none.  The 
   * container may be a RESULT_TYPE_REMOTE_CONTAINER node that has been 
   * dynamically generated by the remote container API.  It may also be a 
   * bookmark folder (RESULT_TYPE_FOLDER) for which some service (such as 
   * livemarks) has registered to provide certain operations.
   */
  /* readonly attribute AUTF8String remoteContainerType; */
  char[] RemoteContainerType(){
    scope auto value = new ACString();
    nsresult __result = inner.GetRemoteContainerType(cast(nsACString*)value);
    CheckException(__result);
    return value.GetString();
  }

private:
  nsINavHistoryContainerResultNode inner;

}


/* starting wrapper class:    nsINavHistoryQueryResultNode */
class nsINavHistoryQueryResultNodeD : public nsINavHistoryContainerResultNodeD {

  static const nsIID IID = NS_INAVHISTORYQUERYRESULTNODE_IID;


  alias nsINavHistoryQueryResultNode InnerType;

  this(nsINavHistoryQueryResultNode intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryQueryResultNode opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryQueryResultNode value) {
    inner = value;
  }

  /**
   * Appends a full visit node to this container and returns it. For the remote
   * container API. TO BE CALLED FROM nsIRemoteContainer::OnContainerOpening()
   * ONLY, and only for non-bookmark-folder containers.
   *
   * @see nsINavHistoryURIResultNode for parameters.
   *
   * UNTESTED: Container API functions are commented out until we can test
   */
/**
   * Appends a full visit node to this container and returns it. For the remote
   * container API. TO BE CALLED FROM nsIRemoteContainer::OnContainerOpening()
   * ONLY, and only for non-bookmark-folder containers.
   *
   * @see nsINavHistoryVisitResultNode for parameters.
   *
   * UNTESTED: Container API functions are commented out until we can test
   */
/**
   * Appends a full visit node to this container and returns it. For the remote
   * container API. TO BE CALLED FROM nsIRemoteContainer::OnContainerOpening()
   * ONLY, and only for non-bookmark-folder containers.
   *
   * @see nsINavHistoryFullVisitResultNode for parameters.
   *
   * UNTESTED: Container API functions are commented out until we can test
   */
/**
   * Appends a container node to this container and returns it. For the remote
   * container API. TO BE CALLED FROM nsIRemoteContainer::OnContainerOpening()
   * ONLY, and only for non-bookmark-folder containers.
   *
   * aContainerType should be either RESULT_TYPE_HOST or
   * RESULT_TYPE_REMOTE_CONTAINER. When type is remote container you must
   * specify a remote container type, otherwise, the remote container type must
   * be null. Use appendQueryNode and appendFolderNode for the other container
   * types.
   *
   * UNTESTED: Container API functions are commented out until we can test
   */
/**
   * Appends a query node to this container and returns it. For the remote
   * container API. TO BE CALLED FROM nsIRemoteContainer::OnContainerOpening()
   * ONLY, and only for non-bookmark-folder containers.
   *
   * Normally you should supply an empty string for IconURI and it will take
   * the default query icon for the current theme.
   *
   * UNTESTED: Container API functions are commented out until we can test
   */
/**
   * Appends a bookmark folder node to this container and returns it. For the
   * remote container API. TO BE CALLED FROM nsIRemoteContainer::OnContainerOpening()
   * ONLY, and only for non-bookmark-folder containers.
   *
   * All container attributes will come from the boomkarks service for this
   * folder.
   *
   * UNTESTED: Container API functions are commented out until we can test
   */
/**
   * Clears all children of this container. For the remote container API.
   * TO BE CALLED FROM nsIRemoteContainer::OnContainerOpening and
   * nsIRemoteContainer::OnContainerClosed ONLY, and valid only for
   * non-bookmark-folder containers.
   *
   * UNTESTED: Container API functions are commented out until we can test
   */
/**
 * Used for places queries and as a base for bookmark folders.
 *
 * Note that if you request places to *not* be expanded in the options that
 * generated this node, this item will report it has no children and never try
 * to populate itself.
 */
/**
   * Get the queries which build this node's children.
   * Only valid for RESULT_TYPE_QUERY nodes.
   */
  /* void getQueries (out unsigned long queryCount, [array, size_is (queryCount), retval] out nsINavHistoryQuery queries); */
  void GetQueries(out PRUint32 queryCount, out nsINavHistoryQueryD *queries){
    nsINavHistoryQuery _queries;
    nsresult __result = inner.GetQueries(&queryCount, &_queries);
    CheckException(__result);
    queries = _queries ? new nsINavHistoryQueryD(_queries) : null;
  }

  /**
   * Get the options which group this node's children.
   * Only valid for RESULT_TYPE_QUERY nodes.
   */
  /* readonly attribute nsINavHistoryQueryOptions queryOptions; */
  nsINavHistoryQueryOptionsD  QueryOptions(){
    nsINavHistoryQueryOptions value;
    nsresult __result = inner.GetQueryOptions(&value);
    CheckException(__result);
    return new nsINavHistoryQueryOptionsD(value);
  }

private:
  nsINavHistoryQueryResultNode inner;

}


/* starting wrapper class:    nsINavHistoryFolderResultNode */
class nsINavHistoryFolderResultNodeD : public nsINavHistoryQueryResultNodeD {

  static const nsIID IID = NS_INAVHISTORYFOLDERRESULTNODE_IID;


  alias nsINavHistoryFolderResultNode InnerType;

  this(nsINavHistoryFolderResultNode intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryFolderResultNode opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryFolderResultNode value) {
    inner = value;
  }

  /**
 * Represents a bookmark folder (type == RESULT_TYPE_FOLDER). It derives from a
 * query result because it can provide a query that will result in the
 * contents.
 */
/**
   * ID of the folder corresponding to this node.
   * Only valid for RESULT_TYPE_QUERY nodes where exactly one folder
   * has been specified in the query.  0 in all other cases.
   */
  /* readonly attribute PRInt64 folderId; */
  PRInt64 FolderId(){
    PRInt64 value;
    nsresult __result = inner.GetFolderId(&value);
    CheckException(__result);
    return value;
  }

private:
  nsINavHistoryFolderResultNode inner;

}


/* starting wrapper class:    nsINavHistoryResultViewObserver */
/**
 *  Allows clients of the HistoryResult to define domain specific handling 
 *  of specific nsITreeView methods that the HistoryResult does not implement.
 *
 *  @see nsINavHistoryResult for where this fits in
 */
class nsINavHistoryResultViewObserverD : public nsISupportsD {

  static const nsIID IID = NS_INAVHISTORYRESULTVIEWOBSERVER_IID;


  alias nsINavHistoryResultViewObserver InnerType;

  this(nsINavHistoryResultViewObserver intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryResultViewObserver opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryResultViewObserver value) {
    inner = value;
  }

  enum { DROP_BEFORE = -1 }

  enum { DROP_ON = 0 }

  enum { DROP_AFTER = 1 }

  /**
   * Methods used by the drag feedback code to determine if a drag is allowable at
   * the current location. To get the behavior where drops are only allowed on
   * items, such as the mailNews folder pane, always return false whe
   * the orientation is not DROP_ON. Implementors should not change the content of
   * the observer list!
   */
  /* boolean canDrop (in long index, in long orientation); */
  PRBool CanDrop(PRInt32 index, PRInt32 orientation){
    PRBool _retval;
    nsresult __result = inner.CanDrop(index, orientation, &_retval);
    CheckException(__result);
    return _retval;
  }

  /**
   * Called when the user drops something on this view. The |orientation| param
   * specifies before/on/after the given |row|.
   */
  /* void onDrop (in long row, in long orientation); */
  void OnDrop(PRInt32 row, PRInt32 orientation){
    nsresult __result = inner.OnDrop(row, orientation);
    CheckException(__result);
  }

  /** 
   * Called when an item is opened or closed. 
   */
  /* void onToggleOpenState (in long index); */
  void OnToggleOpenState(PRInt32 index){
    nsresult __result = inner.OnToggleOpenState(index);
    CheckException(__result);
  }

  /** 
 * Called when a header is clicked.
   */
  /* void onCycleHeader (in nsITreeColumn column); */
  void OnCycleHeader(nsITreeColumnD column){
    nsresult __result = inner.OnCycleHeader(column ? cast(nsITreeColumn)column : null);
    CheckException(__result);
  }

  /**
   * Called when a cell in a non-selectable cycling column (e.g. 
   * unread/flag/etc.) is clicked.
   */
  /* void onCycleCell (in long row, in nsITreeColumn column); */
  void OnCycleCell(PRInt32 row, nsITreeColumnD column){
    nsresult __result = inner.OnCycleCell(row, column ? cast(nsITreeColumn)column : null);
    CheckException(__result);
  }

  /** 
   * Called when selection in the tree changes
   */
  /* void onSelectionChanged (); */
  void OnSelectionChanged(){
    nsresult __result = inner.OnSelectionChanged();
    CheckException(__result);
  }

  /**
   * A command API that can be used to invoke commands on the selection.  
   * The tree will automatically invoke this method when certain keys 
   * are pressed.  For example, when the DEL key is pressed, performAction 
   * will be called with the "delete" string. 
   */
  /* void onPerformAction (in wstring action); */
  void OnPerformAction(PRUnichar*action){
    nsresult __result = inner.OnPerformAction(action);
    CheckException(__result);
  }

  /**
   * A command API that can be used to invoke commands on a specific row.
   */
  /* void onPerformActionOnRow (in wstring action, in long row); */
  void OnPerformActionOnRow(PRUnichar*action, PRInt32 row){
    nsresult __result = inner.OnPerformActionOnRow(action, row);
    CheckException(__result);
  }

  /**
   * A command API that can be used to invoke commands on a specific cell.
   */
  /* void onPerformActionOnCell (in wstring action, in long row, in nsITreeColumn column); */
  void OnPerformActionOnCell(PRUnichar*action, PRInt32 row, nsITreeColumnD column){
    nsresult __result = inner.OnPerformActionOnCell(action, row, column ? cast(nsITreeColumn)column : null);
    CheckException(__result);
  }

private:
  nsINavHistoryResultViewObserver inner;

}


/* starting wrapper class:    nsINavHistoryResultViewer */
/**
 * Allows clients to observe what is happening to a result as it updates itself
 * according to history and bookmark system events. Register this observer on a
 * result using registerView
 *
 * @see nsINavHistoryResult for where this fits in
 */
class nsINavHistoryResultViewerD : public nsISupportsD {

  static const nsIID IID = NS_INAVHISTORYRESULTVIEWER_IID;


  alias nsINavHistoryResultViewer InnerType;

  this(nsINavHistoryResultViewer intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryResultViewer opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryResultViewer value) {
    inner = value;
  }

  /**
   * Called when 'item' is inserted into 'parent' at index 'newIndex'. The item
   * previously at index (if any) and everything below it will have been
   * shifted down by one. The item may be a container or a leaf.
   */
  /* void itemInserted (in nsINavHistoryContainerResultNode parent, in nsINavHistoryResultNode item, in PRUint32 newIndex); */
  void ItemInserted(nsINavHistoryContainerResultNodeD parent, nsINavHistoryResultNodeD item, PRUint32 newIndex){
    nsresult __result = inner.ItemInserted(parent ? cast(nsINavHistoryContainerResultNode)parent : null, item ? cast(nsINavHistoryResultNode)item : null, newIndex);
    CheckException(__result);
  }

  /**
   * Called whan 'item' is removed from 'parent' at 'oldIndex'. The item may be
   * a container or a leaf. This function will be called after the item has
   * been removed from its parent list, but before anything else (including
   * NULLing out the item's parent) has happened.
   */
  /* void itemRemoved (in nsINavHistoryContainerResultNode parent, in nsINavHistoryResultNode item, in PRUint32 oldIndex); */
  void ItemRemoved(nsINavHistoryContainerResultNodeD parent, nsINavHistoryResultNodeD item, PRUint32 oldIndex){
    nsresult __result = inner.ItemRemoved(parent ? cast(nsINavHistoryContainerResultNode)parent : null, item ? cast(nsINavHistoryResultNode)item : null, oldIndex);
    CheckException(__result);
  }

  /**
   * Called when an item has been changed and should be repainted. This only
   * refers to the specific item. If it is a container, getting this message
   * does not imply anything happened to the children. You'll get separate
   * messages for those. Also, this may be called for container nodes at times
   * when the result thinks it's possible that a twisty mey need to bw redrawn.
   */
  /* void itemChanged (in nsINavHistoryResultNode item); */
  void ItemChanged(nsINavHistoryResultNodeD item){
    nsresult __result = inner.ItemChanged(item ? cast(nsINavHistoryResultNode)item : null);
    CheckException(__result);
  }

  /**
   * Called when an item is being replaced with another item at the exact
   * same position.
   */
  /* void itemReplaced (in nsINavHistoryContainerResultNode parent, in nsINavHistoryResultNode oldItem, in nsINavHistoryResultNode newItem, in PRUint32 index); */
  void ItemReplaced(nsINavHistoryContainerResultNodeD parent, nsINavHistoryResultNodeD oldItem, nsINavHistoryResultNodeD newItem, PRUint32 index){
    nsresult __result = inner.ItemReplaced(parent ? cast(nsINavHistoryContainerResultNode)parent : null, oldItem ? cast(nsINavHistoryResultNode)oldItem : null, newItem ? cast(nsINavHistoryResultNode)newItem : null, index);
    CheckException(__result);
  }

  /**
   * Called after a container node went from closed to opened.
   */
  /* void containerOpened (in nsINavHistoryContainerResultNode item); */
  void ContainerOpened(nsINavHistoryContainerResultNodeD item){
    nsresult __result = inner.ContainerOpened(item ? cast(nsINavHistoryContainerResultNode)item : null);
    CheckException(__result);
  }

  /**
   * Called after a container node went from opened to closed. This will be
   * called for the topmost container that is closing, and implies that any
   * child containers have closed as well.
   */
  /* void containerClosed (in nsINavHistoryContainerResultNode item); */
  void ContainerClosed(nsINavHistoryContainerResultNodeD item){
    nsresult __result = inner.ContainerClosed(item ? cast(nsINavHistoryContainerResultNode)item : null);
    CheckException(__result);
  }

  /**
   * Called when something significant has happened within the container. The
   * contents of the container should be re-built.
   */
  /* void invalidateContainer (in nsINavHistoryContainerResultNode item); */
  void InvalidateContainer(nsINavHistoryContainerResultNodeD item){
    nsresult __result = inner.InvalidateContainer(item ? cast(nsINavHistoryContainerResultNode)item : null);
    CheckException(__result);
  }

  /**
   * Called when something significant is changing that requires everything
   * to be recomputed. For example, changing sorting or changing collapse
   * duplicates can affect every row.
   */
  /* void invalidateAll (); */
  void InvalidateAll(){
    nsresult __result = inner.InvalidateAll();
    CheckException(__result);
  }

  /**
   * This is called to indicate to the UI that the sort has changed to the
   * given mode. For trees, for example, this would update the column headers
   * to reflect the sorting. For many other types of views, this won't be
   * applicable.
   *
   * @param sortingMode  One of nsINavHistoryQueryOptions.SORT_BY_* that
   *                     indicates the new sorting mode.
   *
   * This only is expected to update the sorting UI. invalidateAll() will also
   * get called if the sorting changes to update everything.
   */
  /* void sortingChanged (in PRUint32 sortingMode); */
  void SortingChanged(PRUint32 sortingMode){
    nsresult __result = inner.SortingChanged(sortingMode);
    CheckException(__result);
  }

  /**
   * Called by the result when this object is set using
   * nsINavHistoryResult.viewer. This will be set to NULL when the result
   * is being deallocated. This should not be set by other code.
   */
  /* attribute nsINavHistoryResult result; */
  nsINavHistoryResultD  Result(){
    nsINavHistoryResult value;
    nsresult __result = inner.GetResult(&value);
    CheckException(__result);
    return new nsINavHistoryResultD(value);
  }
  void Result(nsINavHistoryResultD  aResult){
    nsINavHistoryResult value;
    nsresult __result = inner.SetResult(value);
    CheckException(__result);
  }

  /**
   * Adds the specified view observer to the view. In ownsWeak is false, then
   * the result will hold a strong reference to the observer. If ownsWeak is
   * true, then the observer must implement nsISupportsWeakReference, and the
   * result will hold a weak reference to the observer.
   */
  /* void addViewObserver (in nsINavHistoryResultViewObserver observer, in boolean ownsWeak); */
  void AddViewObserver(nsINavHistoryResultViewObserverD observer, PRBool ownsWeak){
    nsresult __result = inner.AddViewObserver(observer ? cast(nsINavHistoryResultViewObserver)observer : null, ownsWeak);
    CheckException(__result);
  }

  /**
   * Removes the specified view observer from this view. This observer must
   * have been previously registered using addViewObserver.
   */
  /* void removeViewObserver (in nsINavHistoryResultViewObserver observer); */
  void RemoveViewObserver(nsINavHistoryResultViewObserverD observer){
    nsresult __result = inner.RemoveViewObserver(observer ? cast(nsINavHistoryResultViewObserver)observer : null);
    CheckException(__result);
  }

private:
  nsINavHistoryResultViewer inner;

}


/* starting wrapper class:    nsINavHistoryResultTreeViewer */
/**
 * A predefined view adaptor for interfacing results with an nsITree. This
 * object will remove itself from its associated result when the tree has been
 * detached. This prevents circular references. Users should be aware of this,
 * if you want to re-use the same viewer, you will need to keep your own
 * reference to it and re-initialize it when the tree changes. If you use this
 * object, attach it to a result, never attach it to a tree, and forget about
 * it, it will leak!
 */
class nsINavHistoryResultTreeViewerD : public nsINavHistoryResultViewerD {

  static const nsIID IID = NS_INAVHISTORYRESULTTREEVIEWER_IID;


  alias nsINavHistoryResultTreeViewer InnerType;

  this(nsINavHistoryResultTreeViewer intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryResultTreeViewer opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryResultTreeViewer value) {
    inner = value;
  }

  /**
   * Controls whether duplicate adjacent elements are collapsed into a single
   * item in the tree. This prevents you from seeing multiple entries for
   * things when you have selected to get visits. When you sort by date, the
   * multiple entries will then appear because they will be separated (unless
   * you clicked reload a bunch of times in a row). If you know you'll only
   * ever want one entry per site, you should ask for URIs back instead of
   * visits so it will be more efficient.
   * Default = true
   *
   * Changing this value is somewhat heavyweight since it will force a tree
   * refresh.
   */
  /* attribute boolean collapseDuplicates; */
  PRBool CollapseDuplicates(){
    PRBool value;
    nsresult __result = inner.GetCollapseDuplicates(&value);
    CheckException(__result);
    return value;
  }
  void CollapseDuplicates(PRBool aCollapseDuplicates){
    nsresult __result = inner.SetCollapseDuplicates(aCollapseDuplicates);
    CheckException(__result);
  }

  /**
   * This tells you how many items are in the flattened list of results, i.e.
   * how many rows are in this tree right now. The tree adaptor will also
   * QI to nsITreeView, and this will be the same as nsITreeView.rowCount.
   * This is only valid when a tree is attached, the result will be 0 otherwise.
   */
  /* readonly attribute PRUint32 flatItemCount; */
  PRUint32 FlatItemCount(){
    PRUint32 value;
    nsresult __result = inner.GetFlatItemCount(&value);
    CheckException(__result);
    return value;
  }

  /**
   * This allows you to get at the real node for a given row index. This is
   * only valid when a tree is attached.
   */
  /* nsINavHistoryResultNode nodeForTreeIndex (in PRUint32 aIndex); */
  nsINavHistoryResultNodeD  NodeForTreeIndex(PRUint32 aIndex){
    nsINavHistoryResultNode _retval;
    nsresult __result = inner.NodeForTreeIndex(aIndex, &_retval);
    CheckException(__result);
    return new nsINavHistoryResultNodeD(_retval);
  }

  /**
   * Reverse of nodeForFlatIndex, returns the row index for a given result node.
   * Returns INDEX_INVISIBLE if the item is not visible (for example, its
   * parent is collapsed). This is only valid when a tree is attached. The
   * the result will always be INDEX_INVISIBLE if not.
   * 
   * Note: This sounds sort of obvious, but it got me: aNode must be a node
   *       retrieved from the same result that this viewer is for. If you 
   *       execute another query and get a node from a _different_ result, this 
   *       function will always return the index of that node in the tree that
   *       is attached to that result.
   */
  enum { INDEX_INVISIBLE = 4294967295U }

  /* PRUint32 treeIndexForNode (in nsINavHistoryResultNode aNode); */
  PRUint32 TreeIndexForNode(nsINavHistoryResultNodeD aNode){
    PRUint32 _retval;
    nsresult __result = inner.TreeIndexForNode(aNode ? cast(nsINavHistoryResultNode)aNode : null, &_retval);
    CheckException(__result);
    return _retval;
  }

private:
  nsINavHistoryResultTreeViewer inner;

}


/* starting wrapper class:    nsINavHistoryResult */
class nsINavHistoryResultD : public nsISupportsD {

  static const nsIID IID = NS_INAVHISTORYRESULT_IID;


  alias nsINavHistoryResult InnerType;

  this(nsINavHistoryResult intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryResult opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryResult value) {
    inner = value;
  }

  /**
 * The result of a history/bookmark query.
 *
 * Use the "root" element to access the children of this query.
 *
 * The basic design of the system is a model-view-controller. This result object
 * represents the model where the data is stored. External components
 * provide the view and controller which define how the data looks and how
 * interaction happens.
 *                           +-- nsINavHistoryResultViewObserver
 *                           |
 *   [RESULT]----->[viewer]----->[controller]
 *             |
 *             +-- nsINavHistoryResultViewer
 *
 * The result indicates to the view when something changes through the
 * nsINavHistoryResultViewer interface. Viewers register themselves through
 * the nsINavHistoryResult.RegisterViewer. The viewer interface would then tell
 * the actual view object what to do. A nsINavHistoryResultTreeViewer is
 * provided which provides pre-packaged interaction with a nsITreeBoxObject.
 * Other views will need to provide their own viewer interfaces.
 *
 * The viewer provides notifications to the controller when view events occur
 * through the nsINavHistoryResultViewObserver interface.
 */
/**
   * Sorts all nodes recursively by the given parameter, one of
   * nsINavHistoryQueryOptions.SORT_BY_*  This will update the corresponding
   * options for this result, so that re-using the current options/queries will
   * always give you the current view.
   */
  /* attribute PRUint32 sortingMode; */
  PRUint32 SortingMode(){
    PRUint32 value;
    nsresult __result = inner.GetSortingMode(&value);
    CheckException(__result);
    return value;
  }
  void SortingMode(PRUint32 aSortingMode){
    PRUint32 value;
    nsresult __result = inner.SetSortingMode(value);
    CheckException(__result);
  }

  /**
   * The viewer for this result (see comment for the class for how these
   * objects are related). This may be null, in which case you can still
   * manually walk the tree using the root node. When this is non-null, you
   * can access the flattened list of items (flatItemCount, nodeForFlatIndex,
   * flatIndexForNode).
   */
  /* attribute nsINavHistoryResultViewer viewer; */
  nsINavHistoryResultViewerD  Viewer(){
    nsINavHistoryResultViewer value;
    nsresult __result = inner.GetViewer(&value);
    CheckException(__result);
    return new nsINavHistoryResultViewerD(value);
  }
  void Viewer(nsINavHistoryResultViewerD  aViewer){
    nsINavHistoryResultViewer value;
    nsresult __result = inner.SetViewer(value);
    CheckException(__result);
  }

  /**
   * This is the root of the results.  It will either be a
   * nsINavHistoryFolderResultNode (if the query is for bookmarks matching a
   * single folder) or just a nsINavHistoryQueryResultNode (for everything
   * else). Remember that you need to open all containers for their contents 
   * to be valid.
   */
  /* readonly attribute nsINavHistoryQueryResultNode root; */
  nsINavHistoryQueryResultNodeD  Root(){
    nsINavHistoryQueryResultNode value;
    nsresult __result = inner.GetRoot(&value);
    CheckException(__result);
    return new nsINavHistoryQueryResultNodeD(value);
  }

private:
  nsINavHistoryResult inner;

}


/* starting wrapper class:    nsINavHistoryObserver */
/**
 * Similar to nsIRDFObserver for history. Note that we don't pass the data
 * source since that is always the global history.
 *
 * DANGER! If you are in the middle of a batch transaction, there may be a
 * database transaction active. You can still access the DB, but be careful.
 */
class nsINavHistoryObserverD : public nsISupportsD {

  static const nsIID IID = NS_INAVHISTORYOBSERVER_IID;


  alias nsINavHistoryObserver InnerType;

  this(nsINavHistoryObserver intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryObserver opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryObserver value) {
    inner = value;
  }

  /**
   * Notifies you that a bunch of things are about to change, don't do any
   * heavy-duty processing until onEndUpdateBatch is called.
   */
  /* void onBeginUpdateBatch (); */
  void OnBeginUpdateBatch(){
    nsresult __result = inner.OnBeginUpdateBatch();
    CheckException(__result);
  }

  /**
   * Notifies you that we are done doing a bunch of things and you should go
   * ahead and update UI, etc.
   */
  /* void onEndUpdateBatch (); */
  void OnEndUpdateBatch(){
    nsresult __result = inner.OnEndUpdateBatch();
    CheckException(__result);
  }

  /**
   * Called when a resource is visited. This is called the first time a
   * resource (page, image, etc.) is seen as well as every subsequent time.
   *
   * Normally, transition types of TRANSITION_EMBED (corresponding to images in
   * a page, for example) are not displayed in history results (unless
   * includeHidden is set). Many observers can ignore _EMBED notifications
   * (which will comprise the majority of visit notifications) to save work.
   *
   * @param aVisitID        ID of the visit that was just created.
   * @param aTime           Time of the visit
   * @param aSessionID      The ID of one connected sequence of visits.
   * @param aReferringID    The ID of the visit the user came from. 0 if empty.
   * @param aTransitionType One of nsINavHistory.TRANSITION_*
   */
  /* void onVisit (in nsIURI aURI, in PRInt64 aVisitID, in PRTime aTime, in PRInt64 aSessionID, in PRInt64 aReferringID, in PRUint32 aTransitionType); */
  void OnVisit(nsIURID aURI, PRInt64 aVisitID, PRTime aTime, PRInt64 aSessionID, PRInt64 aReferringID, PRUint32 aTransitionType){
    nsresult __result = inner.OnVisit(aURI ? cast(nsIURI)aURI : null, aVisitID, aTime, aSessionID, aReferringID, aTransitionType);
    CheckException(__result);
  }

  /**
   * Called whenever either the "real" title or the custom title of the page
   * changed. BOTH TITLES ARE ALWAYS INCLUDED in this notification, even though
   * only one will change at a time. Often, consumers will want to display the
   * user title if it is available, and fall back to the page title (the one
   * specified in the <title> tag of the page).
   *
   * Note that there is a difference between an empty title and a NULL title.
   * An empty string means that somebody specifically set the title to be
   * nothing. NULL means nobody set it. From C++: use IsVoid() and SetIsVoid()
   * to see whether an empty string is "null" or not (it will always be an
   * empty string in either case).
   *
   * @param aUserTitleChanged Is true if the user title was the thing that was
   *                          changed. If false, that means the "real" page
   *                          title was changed instead.
   */
  /* void onTitleChanged (in nsIURI aURI, in AString aPageTitle, in AString aUserTitle, in PRBool aUserTitleChanged); */
  void OnTitleChanged(nsIURID aURI, wchar[] aPageTitle, wchar[] aUserTitle, PRBool aUserTitleChanged){
    scope auto _aPageTitle = new AString(aPageTitle);
    scope auto _aUserTitle = new AString(aUserTitle);
    nsresult __result = inner.OnTitleChanged(aURI ? cast(nsIURI)aURI : null, cast(nsAString*)_aPageTitle, cast(nsAString*)_aUserTitle, aUserTitleChanged);
    CheckException(__result);
  }

  /**
   * This page and all of its visits are being deleted. Note: the page may not
   * necessarily have actually existed for this function to be called.
   *
   * Delete notifications are only 99.99% accurate. Batch delete operations
   * must be done in two steps, so first come notifications, then a bulk
   * delete. If there is some error in the middle (for example, out of memory)
   * then you'll get a notification and it won't get deleted. There's no easy
   * way around this.
   */
  /* void onDeleteURI (in nsIURI aURI); */
  void OnDeleteURI(nsIURID aURI){
    nsresult __result = inner.OnDeleteURI(aURI ? cast(nsIURI)aURI : null);
    CheckException(__result);
  }

  /**
   * Notification that all of history is being deleted.
   */
  /* void onClearHistory (); */
  void OnClearHistory(){
    nsresult __result = inner.OnClearHistory();
    CheckException(__result);
  }

  /**
   * A page has had some attribute on it changed. Note that for TYPED and
   * HIDDEN, the page may not necessarily have been added yet.
   */
  enum { ATTRIBUTE_FAVICON = 3U }

  /* void onPageChanged (in nsIURI aURI, in PRUint32 aWhat, in AString aValue); */
  void OnPageChanged(nsIURID aURI, PRUint32 aWhat, wchar[] aValue){
    scope auto _aValue = new AString(aValue);
    nsresult __result = inner.OnPageChanged(aURI ? cast(nsIURI)aURI : null, aWhat, cast(nsAString*)_aValue);
    CheckException(__result);
  }

  /**
   * Called when a history entry expires. You will recieve notifications that
   * a specific visit has expired with the time of that visit. When the last
   * visit for a history entry expires, the history entry itself is deleted
   * and aWholeEntry is set. (If your observer only cares about URLs and not
   * specific visits, it needs only to listen for aWholeEntry notifications).
   *
   * It is possible for a history entry to be deleted that has no visits if
   * something is out of sync or after a bookmark is deleted that has no
   * visits (thus freeing the history entry). In these cases, aVisitTime will
   * be 0.
   */
  /* void onPageExpired (in nsIURI aURI, in PRTime aVisitTime, in boolean aWholeEntry); */
  void OnPageExpired(nsIURID aURI, PRTime aVisitTime, PRBool aWholeEntry){
    nsresult __result = inner.OnPageExpired(aURI ? cast(nsIURI)aURI : null, aVisitTime, aWholeEntry);
    CheckException(__result);
  }

private:
  nsINavHistoryObserver inner;

}


/* starting wrapper class:    nsINavHistoryQuery */
class nsINavHistoryQueryD : public nsISupportsD {

  static const nsIID IID = NS_INAVHISTORYQUERY_IID;


  alias nsINavHistoryQuery InnerType;

  this(nsINavHistoryQuery intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryQuery opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryQuery value) {
    inner = value;
  }

  /**
 * This object encapsulates all the query parameters you're likely to need
 * when building up history UI. All parameters are ANDed together.
 *
 * This is not intended to be a super-general query mechanism. This was designed
 * so that most queries can be done in only one SQL query. This is important
 * because, if the user has their profile on a networked drive, query latency
 * can be non-negligible.
 */
/**
   * Time range for results (INCLUSIVE). The *TimeReference is one of the
   * constants TIME_RELATIVE_* which indicates how to interpret the
   * corresponding time value.
   *   TIME_RELATIVE_EPOCH (default):
   *     The time is relative to Jan 1 1970 GMT, (this is a normal PRTime)
   *   TIME_RELATIVE_TODAY:
   *     The time is relative to this morning at midnight. Normally used for
   *     queries relative to today. For example, a "past week" query would be
   *     today-6 days -> today+1 day
   *   TIME_RELATIVE_NOW:
   *     The time is relative to right now.
   *
   * Note: PRTime is in MICROseconds since 1 Jan 1970. Javascript date objects
   * are expressed in MILLIseconds since 1 Jan 1970.
   *
   * As a special case, a 0 time relative to TIME_RELATIVE_EPOCH indicates that
   * the time is not part of the query. This is the default, so an empty query
   * will match any time. The has* functions return whether the corresponding
   * time is considered.
   *
   * You can read absolute*Time to get the time value that the currently loaded
   * reference points + offset resolve to.
   */
  enum { TIME_RELATIVE_EPOCH = 0U }

  enum { TIME_RELATIVE_TODAY = 1U }

  enum { TIME_RELATIVE_NOW = 2U }

  /* attribute PRTime beginTime; */
  PRTime BeginTime(){
    PRTime value;
    nsresult __result = inner.GetBeginTime(&value);
    CheckException(__result);
    return value;
  }
  void BeginTime(PRTime aBeginTime){
    PRTime value;
    nsresult __result = inner.SetBeginTime(value);
    CheckException(__result);
  }

  /* attribute PRUint32 beginTimeReference; */
  PRUint32 BeginTimeReference(){
    PRUint32 value;
    nsresult __result = inner.GetBeginTimeReference(&value);
    CheckException(__result);
    return value;
  }
  void BeginTimeReference(PRUint32 aBeginTimeReference){
    PRUint32 value;
    nsresult __result = inner.SetBeginTimeReference(value);
    CheckException(__result);
  }

  /* readonly attribute boolean hasBeginTime; */
  PRBool HasBeginTime(){
    PRBool value;
    nsresult __result = inner.GetHasBeginTime(&value);
    CheckException(__result);
    return value;
  }

  /* readonly attribute PRTime absoluteBeginTime; */
  PRTime AbsoluteBeginTime(){
    PRTime value;
    nsresult __result = inner.GetAbsoluteBeginTime(&value);
    CheckException(__result);
    return value;
  }

  /* attribute PRTime endTime; */
  PRTime EndTime(){
    PRTime value;
    nsresult __result = inner.GetEndTime(&value);
    CheckException(__result);
    return value;
  }
  void EndTime(PRTime aEndTime){
    PRTime value;
    nsresult __result = inner.SetEndTime(value);
    CheckException(__result);
  }

  /* attribute PRUint32 endTimeReference; */
  PRUint32 EndTimeReference(){
    PRUint32 value;
    nsresult __result = inner.GetEndTimeReference(&value);
    CheckException(__result);
    return value;
  }
  void EndTimeReference(PRUint32 aEndTimeReference){
    PRUint32 value;
    nsresult __result = inner.SetEndTimeReference(value);
    CheckException(__result);
  }

  /* readonly attribute boolean hasEndTime; */
  PRBool HasEndTime(){
    PRBool value;
    nsresult __result = inner.GetHasEndTime(&value);
    CheckException(__result);
    return value;
  }

  /* readonly attribute PRTime absoluteEndTime; */
  PRTime AbsoluteEndTime(){
    PRTime value;
    nsresult __result = inner.GetAbsoluteEndTime(&value);
    CheckException(__result);
    return value;
  }

  /**
   * Text search terms.
   */
  /* attribute AString searchTerms; */
  wchar[] SearchTerms(){
    scope auto value = new AString();
    nsresult __result = inner.GetSearchTerms(cast(nsAString*)value);
    CheckException(__result);
    return value.GetString();
  }
  void SearchTerms(wchar[] aSearchTerms){
    scope auto value = new AString(aSearchTerms);
    nsresult __result = inner.SetSearchTerms(cast(nsAString*)value);
    CheckException(__result);
  }

  /* readonly attribute boolean hasSearchTerms; */
  PRBool HasSearchTerms(){
    PRBool value;
    nsresult __result = inner.GetHasSearchTerms(&value);
    CheckException(__result);
    return value;
  }

  /**
   * When set, returns only bookmarked items, when unset, returns anything. Setting this
   * is equivalent to listing all bookmark folders in the 'folders' parameter.
   */
  /* attribute boolean onlyBookmarked; */
  PRBool OnlyBookmarked(){
    PRBool value;
    nsresult __result = inner.GetOnlyBookmarked(&value);
    CheckException(__result);
    return value;
  }
  void OnlyBookmarked(PRBool aOnlyBookmarked){
    nsresult __result = inner.SetOnlyBookmarked(aOnlyBookmarked);
    CheckException(__result);
  }

  /**
   * This controls the meaning of 'domain', and whether it is an exact match
   * 'domainIsHost' = true, or hierarchical (= false).
   */
  /* attribute boolean domainIsHost; */
  PRBool DomainIsHost(){
    PRBool value;
    nsresult __result = inner.GetDomainIsHost(&value);
    CheckException(__result);
    return value;
  }
  void DomainIsHost(PRBool aDomainIsHost){
    nsresult __result = inner.SetDomainIsHost(aDomainIsHost);
    CheckException(__result);
  }

  /**
   * This is the host or domain name (controlled by domainIsHost). When
   * domainIsHost, domain only does exact matching on host names. Otherwise,
   * it will return anything whose host name ends in 'domain'.
   *
   * This one is a little different than most. Setting it to an empty string
   * is a real query and will match any URI that has no host name (local files
   * and such). Set this to NULL (in C++ use SetIsVoid) if you don't want
   * domain matching.
   */
  /* attribute AUTF8String domain; */
  char[] Domain(){
    scope auto value = new ACString();
    nsresult __result = inner.GetDomain(cast(nsACString*)value);
    CheckException(__result);
    return value.GetString();
  }
  void Domain(char[] aDomain){
    scope auto value = new ACString(aDomain);
    nsresult __result = inner.SetDomain(cast(nsACString*)value);
    CheckException(__result);
  }

  /* readonly attribute boolean hasDomain; */
  PRBool HasDomain(){
    PRBool value;
    nsresult __result = inner.GetHasDomain(&value);
    CheckException(__result);
    return value;
  }

  /**
   * Controls the interpretation of 'uri'. When unset (default), the URI will
   * request an exact match of the specified URI. When set, any history entry
   * beginning in 'uri' will match. For example "http://bar.com/foo" will match
   * "http://bar.com/foo" as well as "http://bar.com/foo/baz.gif".
   */
  /* attribute boolean uriIsPrefix; */
  PRBool UriIsPrefix(){
    PRBool value;
    nsresult __result = inner.GetUriIsPrefix(&value);
    CheckException(__result);
    return value;
  }
  void UriIsPrefix(PRBool aUriIsPrefix){
    nsresult __result = inner.SetUriIsPrefix(aUriIsPrefix);
    CheckException(__result);
  }

  /**
   * This is a URI to match, to, for example, find out every time you visited
   * a given URI. Use uriIsPrefix to control whether this is an exact match.
   */
  /* attribute nsIURI uri; */
  nsIURID  Uri(){
    nsIURI value;
    nsresult __result = inner.GetUri(&value);
    CheckException(__result);
    return new nsIURID(value);
  }
  void Uri(nsIURID  aUri){
    nsIURI value;
    nsresult __result = inner.SetUri(value);
    CheckException(__result);
  }

  /* readonly attribute boolean hasUri; */
  PRBool HasUri(){
    PRBool value;
    nsresult __result = inner.GetHasUri(&value);
    CheckException(__result);
    return value;
  }

  /**
   * Test for existance or non-existance of a given annotation. We don't
   * currently support >1 annotation name per query. If 'annotationIsNot' is
   * true, we test for the non-existance of the specified annotation.
   *
   * Testing for not annotation will do the same thing as a normal query and
   * remove everything that doesn't have that annotation. Asking for things
   * that DO have a given annotation is a little different. It also includes
   * things that have never been visited. This allows place queries to be
   * returned (which might include bookmark folders -- use the bookmark
   * service's GetFolderURI) as well as anything else that may have been
   * tagged with an annotation. This will only work for RESULTS_AS_URI since
   * there will be no visits for these items.
   */
  /* attribute boolean annotationIsNot; */
  PRBool AnnotationIsNot(){
    PRBool value;
    nsresult __result = inner.GetAnnotationIsNot(&value);
    CheckException(__result);
    return value;
  }
  void AnnotationIsNot(PRBool aAnnotationIsNot){
    nsresult __result = inner.SetAnnotationIsNot(aAnnotationIsNot);
    CheckException(__result);
  }

  /* attribute AUTF8String annotation; */
  char[] Annotation(){
    scope auto value = new ACString();
    nsresult __result = inner.GetAnnotation(cast(nsACString*)value);
    CheckException(__result);
    return value.GetString();
  }
  void Annotation(char[] aAnnotation){
    scope auto value = new ACString(aAnnotation);
    nsresult __result = inner.SetAnnotation(cast(nsACString*)value);
    CheckException(__result);
  }

  /* readonly attribute boolean hasAnnotation; */
  PRBool HasAnnotation(){
    PRBool value;
    nsresult __result = inner.GetHasAnnotation(&value);
    CheckException(__result);
    return value;
  }

  /**
   * Limit results to items that are in all of the given folders.
   */
  /* void getFolders (out PRUint32 count, [array, size_is (count), retval] out PRInt64 folders); */
  void GetFolders(out PRUint32 count, out PRInt64 *folders){
    nsresult __result = inner.GetFolders(&count, &folders);
    CheckException(__result);
  }

  /* readonly attribute PRUint32 folderCount; */
  PRUint32 FolderCount(){
    PRUint32 value;
    nsresult __result = inner.GetFolderCount(&value);
    CheckException(__result);
    return value;
  }

  /* void setFolders ([array, size_is (folderCount), const] in PRInt64 folders, in PRUint32 folderCount); */
  void SetFolders(PRInt64 *folders, PRUint32 folderCount){
    nsresult __result = inner.SetFolders(folders, folderCount);
    CheckException(__result);
  }

  /**
   * Creates a new query item with the same parameters of this one.
   */
  /* nsINavHistoryQuery clone (); */
  nsINavHistoryQueryD  Clone(){
    nsINavHistoryQuery _retval;
    nsresult __result = inner.Clone(&_retval);
    CheckException(__result);
    return new nsINavHistoryQueryD(_retval);
  }

private:
  nsINavHistoryQuery inner;

}


/* starting wrapper class:    nsINavHistoryQueryOptions */
class nsINavHistoryQueryOptionsD : public nsISupportsD {

  static const nsIID IID = NS_INAVHISTORYQUERYOPTIONS_IID;


  alias nsINavHistoryQueryOptions InnerType;

  this(nsINavHistoryQueryOptions intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryQueryOptions opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryQueryOptions value) {
    inner = value;
  }

  /**
 * This object represents the global options for executing a query.
 */
/**
   * Groping by exact host. The results will be an array of nsINavHistoryResults
   * with type = RESULT_TYPE_HOST, one for each unique host (for example,
   * "bugzilla.mozilla.org" and "www.mozilla.org" will be separate). The
   * children of these will correspond to the results for each host.
   */
  enum { GROUP_BY_HOST = 1U }

  /**
   * Grouping by toplevel domain. Similar to GROUP_BY_HOST, but there will be
   * one result for each toplevel domain (mozilla.org will be one entry, and
   * will contain results including, for example, "bugzilla.mozilla.org" and
   * "www.mozilla.org").
   */
  enum { GROUP_BY_DOMAIN = 2U }

  /**
   * Group by bookmark folder.  Since this determines the entire subtree
   * hierarchy, it must be the last grouping option given.  This option
   * requires the query to have onlyBookmarked set, and for there to be
   * at least one parent folder specified via nsINavHistoryQuery::setFolders.
   * If all of the top-level results belong to a single folder, the folder will
   * be omitted and its children will become the toplevel result nodes.
   */
  enum { GROUP_BY_FOLDER = 3U }

  /**
   * You can ask for the results to be pre-sorted. Since the DB has indices
   * of many items, it can produce sorted results almost for free. These should
   * be self-explanatory.
   *
   * Note: re-sorting is slower, as is sorting by title or when you have a
   * host name.
   *
   * For bookmark items, SORT_BY_NONE means sort by the natural bookmark order.
   */
  enum { SORT_BY_NONE = 0U }

  enum { SORT_BY_TITLE_ASCENDING = 1U }

  enum { SORT_BY_TITLE_DESCENDING = 2U }

  enum { SORT_BY_DATE_ASCENDING = 3U }

  enum { SORT_BY_DATE_DESCENDING = 4U }

  enum { SORT_BY_URI_ASCENDING = 5U }

  enum { SORT_BY_URI_DESCENDING = 6U }

  enum { SORT_BY_VISITCOUNT_ASCENDING = 7U }

  enum { SORT_BY_VISITCOUNT_DESCENDING = 8U }

  /**
   * "URI" results, one for each URI visited in the range. Individual result
   * nodes will be of type "URI".
   */
  enum { RESULTS_AS_URI = 0U }

  /**
   * "Visit" results, with one for each time a page was visited (this will
   * often give you multiple results for one URI). Individual result nodes will
   * have type "Visit"
   */
  enum { RESULTS_AS_VISIT = 1U }

  /**
   * This is identical to RESULT_TYPE_VISIT except that individual result nodes
   * will have type "FullVisit".  This is used for the attributes that are not
   * commonly accessed to save space in the common case (the lists can be very
   * long).
   */
  enum { RESULTS_AS_FULL_VISIT = 2U }

  /**
   * The grouping mode to be used for this query.
   * Grouping mode is an array of GROUP_BY_* values that specifies the
   * structure of the tree you want. If you don't want grouping, you can
   * specify an empty array.
   */
  /* void getGroupingMode (out PRUint32 groupCount, [array, size_is (groupCount), retval] out PRUint32 groupingMode); */
  void GetGroupingMode(out PRUint32 groupCount, out PRUint32 *groupingMode){
    nsresult __result = inner.GetGroupingMode(&groupCount, &groupingMode);
    CheckException(__result);
  }

  /* void setGroupingMode ([array, size_is (groupCount), const] in PRUint32 groupingMode, in PRUint32 groupCount); */
  void SetGroupingMode(PRUint32 *groupingMode, PRUint32 groupCount){
    nsresult __result = inner.SetGroupingMode(groupingMode, groupCount);
    CheckException(__result);
  }

  /**
   * The sorting mode to be used for this query.
   * mode is one of SORT_BY_*
   */
  /* attribute PRUint32 sortingMode; */
  PRUint32 SortingMode(){
    PRUint32 value;
    nsresult __result = inner.GetSortingMode(&value);
    CheckException(__result);
    return value;
  }
  void SortingMode(PRUint32 aSortingMode){
    PRUint32 value;
    nsresult __result = inner.SetSortingMode(value);
    CheckException(__result);
  }

  /**
   * Sets the result type. One of RESULT_TYPE_* which includes how URIs are
   * represented.
   */
  /* attribute PRUint32 resultType; */
  PRUint32 ResultType(){
    PRUint32 value;
    nsresult __result = inner.GetResultType(&value);
    CheckException(__result);
    return value;
  }
  void ResultType(PRUint32 aResultType){
    PRUint32 value;
    nsresult __result = inner.SetResultType(value);
    CheckException(__result);
  }

  /**
   * This option excludes all URIs and separators from a bookmarks query.
   * This would be used if you just wanted a list of bookmark folders and
   * queries (such as the left pane of the places page).
   * Ignored for queries over history. Defaults to false.
   */
  /* attribute boolean excludeItems; */
  PRBool ExcludeItems(){
    PRBool value;
    nsresult __result = inner.GetExcludeItems(&value);
    CheckException(__result);
    return value;
  }
  void ExcludeItems(PRBool aExcludeItems){
    nsresult __result = inner.SetExcludeItems(aExcludeItems);
    CheckException(__result);
  }

  /**
   * Set to true to exclude queries ("place:" URIs) from the query results.
   * Simple folder queries (bookmark folder symlinks) will still be included.
   * Defaults to false.
   */
  /* attribute boolean excludeQueries; */
  PRBool ExcludeQueries(){
    PRBool value;
    nsresult __result = inner.GetExcludeQueries(&value);
    CheckException(__result);
    return value;
  }
  void ExcludeQueries(PRBool aExcludeQueries){
    nsresult __result = inner.SetExcludeQueries(aExcludeQueries);
    CheckException(__result);
  }

  /**
   * Set to true to exclude read-only folders from the query results. This is
   * designed for cases where you want to give the user the option of filing
   * something into a list of folders. It only affects cases where the actual
   * folder result node would appear in its parent folder and filters it out.
   * It doesn't affect the query at all, and doesn't affect more complex
   * queries (such as "folders with annotation X").
   */
  /* attribute boolean excludeReadOnlyFolders; */
  PRBool ExcludeReadOnlyFolders(){
    PRBool value;
    nsresult __result = inner.GetExcludeReadOnlyFolders(&value);
    CheckException(__result);
    return value;
  }
  void ExcludeReadOnlyFolders(PRBool aExcludeReadOnlyFolders){
    nsresult __result = inner.SetExcludeReadOnlyFolders(aExcludeReadOnlyFolders);
    CheckException(__result);
  }

  /**
   * When set, allows items with "place:" URIs to appear as containers,
   * with the container's contents filled in from the stored query.
   * If not set, these will appear as normal items. Doesn't do anything if
   * excludeQueries is set. Defaults to false.
   *
   * Note that this has no effect on folder links, which are place: URIs
   * returned by nsINavBookmarkService.GetFolderURI. These are always expanded
   * and will appear as bookmark folders.
   */
  /* attribute boolean expandQueries; */
  PRBool ExpandQueries(){
    PRBool value;
    nsresult __result = inner.GetExpandQueries(&value);
    CheckException(__result);
    return value;
  }
  void ExpandQueries(PRBool aExpandQueries){
    nsresult __result = inner.SetExpandQueries(aExpandQueries);
    CheckException(__result);
  }

  /**
   * Normally the title of a result will be the user's custom title if there is
   * one, falling back on the default page title. If this is set, we will not
   * do this operation and always use the original page title extracted from
   * the HTML of the page. Defaults to false.
   */
  /* attribute boolean forceOriginalTitle; */
  PRBool ForceOriginalTitle(){
    PRBool value;
    nsresult __result = inner.GetForceOriginalTitle(&value);
    CheckException(__result);
    return value;
  }
  void ForceOriginalTitle(PRBool aForceOriginalTitle){
    nsresult __result = inner.SetForceOriginalTitle(aForceOriginalTitle);
    CheckException(__result);
  }

  /**
   * Most items in history are marked "hidden." Only toplevel pages that the
   * user sees in the URL bar are not hidden. Hidden things include the content
   * of iframes and all images on web pages. Normally, you don't want these
   * things. If you do, set this flag and you'll get all items, even hidden
   * ones. Does nothing for bookmark queries. Defaults to false.
   */
  /* attribute boolean includeHidden; */
  PRBool IncludeHidden(){
    PRBool value;
    nsresult __result = inner.GetIncludeHidden(&value);
    CheckException(__result);
    return value;
  }
  void IncludeHidden(PRBool aIncludeHidden){
    nsresult __result = inner.SetIncludeHidden(aIncludeHidden);
    CheckException(__result);
  }

  /**
   * This is the maximum number of results that you want. The query is exeucted,
   * the results are sorted, and then the top 'maxResults' results are taken
   * and returned. Set to 0 (the default) to get all results.
   *
   * THIS DOES NOT WORK IN CONJUNCTION WITH SORTING BY TITLE. This is because
   * sorting by title requires us to sort after using locale-sensetive sorting
   * (as opposed to letting the database do it for us).
   *
   * Instead, we get the result ordered by date, pick the maxResult most recent
   * ones, and THEN sort by title.
   */
  /* attribute PRUint32 maxResults; */
  PRUint32 MaxResults(){
    PRUint32 value;
    nsresult __result = inner.GetMaxResults(&value);
    CheckException(__result);
    return value;
  }
  void MaxResults(PRUint32 aMaxResults){
    PRUint32 value;
    nsresult __result = inner.SetMaxResults(value);
    CheckException(__result);
  }

  /**
   * Creates a new options item with the same parameters of this one.
   */
  /* nsINavHistoryQueryOptions clone (); */
  nsINavHistoryQueryOptionsD  Clone(){
    nsINavHistoryQueryOptions _retval;
    nsresult __result = inner.Clone(&_retval);
    CheckException(__result);
    return new nsINavHistoryQueryOptionsD(_retval);
  }

private:
  nsINavHistoryQueryOptions inner;

}


/* starting wrapper class:    nsINavHistoryService */
class nsINavHistoryServiceD : public nsISupportsD {

  static const nsIID IID = NS_INAVHISTORYSERVICE_IID;


  alias nsINavHistoryService InnerType;

  this(nsINavHistoryService intr){
    super(intr);
    this.inner = intr;
  }

  nsINavHistoryService opCast() {
    return inner;
  }

  void opAssign(nsINavHistoryService value) {
    inner = value;
  }

  /**
   * This transition type means the user followed a link and got a new toplevel
   * window.
   */
  enum { TRANSITION_LINK = 1U }

  /**
   * This transition type means that the user typed the page's URL in the
   * URL bar.
   */
  enum { TRANSITION_TYPED = 2U }

  /**
   * This transition is set when the user followed a bookmark to get to the
   * page.
   */
  enum { TRANSITION_BOOKMARK = 3U }

  /**
   * This transition type is set when some inner content is loaded. This is
   * true of all images on a page, and the contents of the iframe. It is also
   * true of any content in a frame, regardless if whether or not the user
   * clicked something to get there.
   */
  enum { TRANSITION_EMBED = 4U }

  /**
   * Set when the transition was a permanent redirect.
   */
  enum { TRANSITION_REDIRECT_PERMANENT = 5U }

  /**
   * Set when the transition was a temporary redirect.
   */
  enum { TRANSITION_REDIRECT_TEMPORARY = 6U }

  /**
   * True if there is any history. This can be used in UI to determine whether
   * the "clear history" button should be enabled or not. This is much better
   * than using BrowserHistory.count since that can be very slow if there is
   * a lot of history (it must enumerate each item). This is pretty fast.
   */
  /* readonly attribute boolean hasHistoryEntries; */
  PRBool HasHistoryEntries(){
    PRBool value;
    nsresult __result = inner.GetHasHistoryEntries(&value);
    CheckException(__result);
    return value;
  }

  /**
   * This sets the user-defined title of the page. Silently fails if we have
   * no knowledge of this page. Set to empty string to clear the user title and
   * only use the "real" title as declared on the page.
   */
  /* void setPageUserTitle (in nsIURI aURI, in AString aUserTitle); */
  void SetPageUserTitle(nsIURID aURI, wchar[] aUserTitle){
    scope auto _aUserTitle = new AString(aUserTitle);
    nsresult __result = inner.SetPageUserTitle(aURI ? cast(nsIURI)aURI : null, cast(nsAString*)_aUserTitle);
    CheckException(__result);
  }

  /**
   * This is just like markPageAsTyped (in nsIBrowserHistory, also implemented
   * by the history service), but for bookmarks. It declares that the given URI
   * is being opened as a result of following a bookmark. If this URI is loaded
   * soon after this message has been received, that transition will be marked
   * as following a bookmark.
   */
  /* void markPageAsFollowedBookmark (in nsIURI aURI); */
  void MarkPageAsFollowedBookmark(nsIURID aURI){
    nsresult __result = inner.MarkPageAsFollowedBookmark(aURI ? cast(nsIURI)aURI : null);
    CheckException(__result);
  }

  /**
   * Returns true if this URI would be added to the history. You don't have to
   * worry about calling this, addPageToSession/addURI will always check before
   * actually adding the page. This function is public because some components
   * may want to check if this page would go in the history (i.e. for
   * annotations).
   */
  /* boolean canAddURI (in nsIURI aURI); */
  PRBool CanAddURI(nsIURID aURI){
    PRBool _retval;
    nsresult __result = inner.CanAddURI(aURI ? cast(nsIURI)aURI : null, &_retval);
    CheckException(__result);
    return _retval;
  }

  /**
   * Call to set the full information for a given page. If the page does not
   * exist, it will be added to the database. If it does, the existing values
   * WILL BE OVERWRITTEN. This is an updated version of addPageWithDetails
   * for backup/restore type operations.
   *
   * @param aURI        Page to add/change.
   * @param aTitle      Title as specified by the page.
   * @param aUserTitle  Custom title provided by user. Set to NULL if none.
   * @param aVisitCount Number of times this page has been visited. Setting this
   *                    to 0 may make the page invisible in some views.
   * @param aHidden     Whether the page is hidden. If the page has only
   *                    TRANSITION_EMBED visits, this will be true, otherwise
   *                    false.
   * @param aTyped      True if this URI has ever been typed.
   */
  /* void setPageDetails (in nsIURI aURI, in AString aTitle, in AString aUserTitle, in PRUint32 aVisitCount, in boolean aHidden, in boolean aTyped); */
  void SetPageDetails(nsIURID aURI, wchar[] aTitle, wchar[] aUserTitle, PRUint32 aVisitCount, PRBool aHidden, PRBool aTyped){
    scope auto _aTitle = new AString(aTitle);
    scope auto _aUserTitle = new AString(aUserTitle);
    nsresult __result = inner.SetPageDetails(aURI ? cast(nsIURI)aURI : null, cast(nsAString*)_aTitle, cast(nsAString*)_aUserTitle, aVisitCount, aHidden, aTyped);
    CheckException(__result);
  }

  /**
   * Call to manually add a visit for a specific page. This will probably not
   * be commonly used other than for backup/restore type operations. If the URI
   * does not have an entry in the history database already, one will be created
   * with no visits, no title, hidden, not typed.  Adding a visit will
   * automatically increment the visit count for the visited page and will unhide
   * it and/or mark it typed according to the transition type.
   *
   * @param aURI             Visited page
   * @param aTime            Time page was visited (microseconds)
   * @param aReferringVisit  The ID of the visit that generated this one. Use 0
   *                         for no referrer. This must be a valid visit already
   *                         in the DB or 0.
   * @param aTranstitionType Type of transition: one of TRANSITION_* above
   * @param aIsRedirect      True if the given visit redirects to somewhere else.
   *                         (ie you will create an visit out of here that is a
   *                         redirect transition). This causes this page to be
   *                         hidden in normal history views (unless it has been
   *                         unhidden by visiting it with a non-redirect).
   * @param aSessionID       The session ID that this page belongs to. Use 0 for
   *                         no session.
   * @returns The ID of the created visit. This will be 0 if the URI is not
   *          valid for adding to history (canAddURI = false).
   */
  /* PRInt64 addVisit (in nsIURI aURI, in PRTime aTime, in PRInt64 aReferringVisit, in PRInt32 aTransitionType, in boolean aIsRedirect, in PRInt64 aSessionID); */
  PRInt64 AddVisit(nsIURID aURI, PRTime aTime, PRInt64 aReferringVisit, PRInt32 aTransitionType, PRBool aIsRedirect, PRInt64 aSessionID){
    PRInt64 _retval;
    nsresult __result = inner.AddVisit(aURI ? cast(nsIURI)aURI : null, aTime, aReferringVisit, aTransitionType, aIsRedirect, aSessionID, &_retval);
    CheckException(__result);
    return _retval;
  }

  /**
   * This returns a new query object that you can pass to executeQuer[y/ies].
   * It will be initialized to all empty (so using it will give you all history).
   */
  /* nsINavHistoryQuery getNewQuery (); */
  nsINavHistoryQueryD  GetNewQuery(){
    nsINavHistoryQuery _retval;
    nsresult __result = inner.GetNewQuery(&_retval);
    CheckException(__result);
    return new nsINavHistoryQueryD(_retval);
  }

  /**
   * This returns a new options object that you can pass to executeQuer[y/ies]
   * after setting the desired options.
   */
  /* nsINavHistoryQueryOptions getNewQueryOptions (); */
  nsINavHistoryQueryOptionsD  GetNewQueryOptions(){
    nsINavHistoryQueryOptions _retval;
    nsresult __result = inner.GetNewQueryOptions(&_retval);
    CheckException(__result);
    return new nsINavHistoryQueryOptionsD(_retval);
  }

  /**
   * Executes a single query.
   */
  /* nsINavHistoryResult executeQuery (in nsINavHistoryQuery aQuery, in nsINavHistoryQueryOptions options); */
  nsINavHistoryResultD  ExecuteQuery(nsINavHistoryQueryD aQuery, nsINavHistoryQueryOptionsD options){
    nsINavHistoryResult _retval;
    nsresult __result = inner.ExecuteQuery(aQuery ? cast(nsINavHistoryQuery)aQuery : null, options ? cast(nsINavHistoryQueryOptions)options : null, &_retval);
    CheckException(__result);
    return new nsINavHistoryResultD(_retval);
  }

  /**
   * Executes an array of queries. All of the query objects are ORed
   * together. Within a query, all the terms are ANDed together as in
   * executeQuery. See executeQuery()
   */
  /* nsINavHistoryResult executeQueries ([array, size_is (aQueryCount)] in nsINavHistoryQuery aQueries, in PRUint32 aQueryCount, in nsINavHistoryQueryOptions options); */
  nsINavHistoryResultD  ExecuteQueries(nsINavHistoryQueryD *aQueries, PRUint32 aQueryCount, nsINavHistoryQueryOptionsD options){
    nsINavHistoryResult _retval;
    nsresult __result = inner.ExecuteQueries(aQueries ? cast(nsINavHistoryQuery)aQueries : null, aQueryCount, options ? cast(nsINavHistoryQueryOptions)options : null, &_retval);
    CheckException(__result);
    return new nsINavHistoryResultD(_retval);
  }

  /**
   * Converts a query URI-like string to an array of actual query objects for
   * use to executeQueries(). The output query array may be empty if there is
   * no information. However, there will always be an options structure returned
   * (if nothing is defined, it will just have the default values).
   */
  /* void queryStringToQueries (in AUTF8String aQueryString, [array, size_is (aResultCount)] out nsINavHistoryQuery aQueries, out PRUint32 aResultCount, out nsINavHistoryQueryOptions options); */
  void QueryStringToQueries(char[] aQueryString, out nsINavHistoryQueryD *aQueries, out PRUint32 aResultCount, out nsINavHistoryQueryOptionsD options){
    scope auto _aQueryString = new ACString(aQueryString);
    nsINavHistoryQuery _aQueries;
    nsINavHistoryQueryOptions _options;
    nsresult __result = inner.QueryStringToQueries(cast(nsACString*)_aQueryString, &_aQueries, &aResultCount, &_options);
    CheckException(__result);
    aQueries = _aQueries ? new nsINavHistoryQueryD(_aQueries) : null;
    options = _options ? new nsINavHistoryQueryOptionsD(_options) : null;
  }

  /**
   * Converts a query into an equivalent string that can be persisted. Inverse
   * of queryStringToQueries()
   */
  /* AUTF8String queriesToQueryString ([array, size_is (aQueryCount)] in nsINavHistoryQuery aQueries, in PRUint32 aQueryCount, in nsINavHistoryQueryOptions options); */
  char[] QueriesToQueryString(nsINavHistoryQueryD *aQueries, PRUint32 aQueryCount, nsINavHistoryQueryOptionsD options){
    scope auto _retval = new ACString;
    nsresult __result = inner.QueriesToQueryString(aQueries ? cast(nsINavHistoryQuery)aQueries : null, aQueryCount, options ? cast(nsINavHistoryQueryOptions)options : null, cast(nsACString*)_retval);
    CheckException(__result);
    return _retval.GetString();
  }

  /**
   * Adds a history observer. If ownsWeak is false, the history service will
   * keep an owning reference to the observer.  If ownsWeak is true, then
   * aObserver must implement nsISupportsWeakReference, and the history service
   * will keep a weak reference to the observer.
   */
  /* void addObserver (in nsINavHistoryObserver observer, in boolean ownsWeak); */
  void AddObserver(nsINavHistoryObserverD observer, PRBool ownsWeak){
    nsresult __result = inner.AddObserver(observer ? cast(nsINavHistoryObserver)observer : null, ownsWeak);
    CheckException(__result);
  }

  /**
   * Removes a history observer.
   */
  /* void removeObserver (in nsINavHistoryObserver observer); */
  void RemoveObserver(nsINavHistoryObserverD observer){
    nsresult __result = inner.RemoveObserver(observer ? cast(nsINavHistoryObserver)observer : null);
    CheckException(__result);
  }

  /**
   * Causes observers to be notified of a beginUpdateBatch when a lot of things
   * are about to change. Calls can be nested, observers will only be
   * notified when all batches begin/end.
   */
  /* void beginUpdateBatch (); */
  void BeginUpdateBatch(){
    nsresult __result = inner.BeginUpdateBatch();
    CheckException(__result);
  }

  /**
   * Causes observers to be notified of an endUpdateBatch when a batch is
   * done changing. Should match beginUpdateBatch or bad things will happen.
   */
  /* void endUpdateBatch (); */
  void EndUpdateBatch(){
    nsresult __result = inner.EndUpdateBatch();
    CheckException(__result);
  }

private:
  nsINavHistoryService inner;

}


/* starting wrapper class:    nsIMorkHistoryImporter */
/**
 * nsIMorkHistoryImporter is a service which handles importing old
 * history files.
 */
class nsIMorkHistoryImporterD : public nsISupportsD {

  static const nsIID IID = NS_IMORKHISTORYIMPORTER_IID;


  alias nsIMorkHistoryImporter InnerType;

  this(nsIMorkHistoryImporter intr){
    super(intr);
    this.inner = intr;
  }

  nsIMorkHistoryImporter opCast() {
    return inner;
  }

  void opAssign(nsIMorkHistoryImporter value) {
    inner = value;
  }

  /**
   * Import the given Mork history file.
   *  @param file     The Mork history file to import
   *  @param history  A reference to the nsINavHistoryService.  This is
   *                  supplied since the importer is invoked during
   *                  history service initialization.
   */
  /* void importHistory (in nsIFile file, in nsINavHistoryService history); */
  void ImportHistory(nsIFileD file, nsINavHistoryServiceD history){
    nsresult __result = inner.ImportHistory(file ? cast(nsIFile)file : null, history ? cast(nsINavHistoryService)history : null);
    CheckException(__result);
  }

private:
  nsIMorkHistoryImporter inner;

}

